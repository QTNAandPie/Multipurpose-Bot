// src/utils/get-paths.ts
import path from "path";
import fs from "fs";
function getFilePaths(directory, nesting) {
  let filePaths = [];
  if (!directory)
    return filePaths;
  const files = fs.readdirSync(directory, { withFileTypes: true });
  for (const file of files) {
    const filePath = path.join(directory, file.name);
    if (file.isFile()) {
      filePaths.push(filePath);
    }
    if (nesting && file.isDirectory()) {
      filePaths = [...filePaths, ...getFilePaths(filePath, true)];
    }
  }
  return filePaths;
}
function getFolderPaths(directory, nesting) {
  let folderPaths = [];
  if (!directory)
    return folderPaths;
  const folders = fs.readdirSync(directory, { withFileTypes: true });
  for (const folder of folders) {
    const folderPath = path.join(directory, folder.name);
    if (folder.isDirectory()) {
      folderPaths.push(folderPath);
      if (nesting) {
        folderPaths = [...folderPaths, ...getFolderPaths(folderPath, true)];
      }
    }
  }
  return folderPaths;
}

// src/utils/resolve-file-url.ts
import path2 from "path";
function toFileURL(filePath) {
  const resolvedPath = path2.resolve(filePath);
  return "file://" + resolvedPath.replace(/\\/g, "/");
}

// src/handlers/command-handler/validations/botPermissions.ts
function botPermissions_default({
  interaction,
  targetCommand
}) {
  const botMember = interaction.guild?.members.me;
  if (targetCommand.options?.botPermissions && botMember) {
    for (const permission of targetCommand.options.botPermissions) {
      const hasPermission = botMember.permissions.has(permission);
      if (!hasPermission) {
        interaction.reply({
          content: `\u274C I do not have enough permission to execute this command. Required permission: \`${permission}\``,
          ephemeral: true
        });
        return true;
      }
    }
  }
}

// src/handlers/command-handler/validations/devOnly.ts
function devOnly_default({
  interaction,
  targetCommand,
  handlerData
}) {
  if (targetCommand.options?.devOnly) {
    if (interaction.inGuild() && !handlerData.devGuildIds.includes(interaction.guildId)) {
      interaction.reply({
        content: "\u274C This command can only be used inside development servers.",
        ephemeral: true
      });
      return true;
    }
    const guildMember = interaction.guild?.members.cache.get(
      interaction.user.id
    );
    const memberRoles = guildMember?.roles.cache;
    let hasDevRole = false;
    memberRoles?.forEach((role) => {
      if (handlerData.devRoleIds?.includes(role.id)) {
        hasDevRole = true;
      }
    });
    const isDevUser = handlerData.devUserIds.includes(interaction.user.id) || hasDevRole;
    if (!isDevUser) {
      interaction.reply({
        content: "\u274C This command can only be used by developers.",
        ephemeral: true
      });
      return true;
    }
  }
}

// src/handlers/command-handler/validations/guildOnly.ts
function guildOnly_default({
  interaction,
  targetCommand
}) {
  if (targetCommand.options?.guildOnly && !interaction.inGuild()) {
    interaction.reply({
      content: "\u274C This command can only be used inside a server.",
      ephemeral: true
    });
    return true;
  }
}

// src/handlers/command-handler/validations/userPermissions.ts
function userPermissions_default({
  interaction,
  targetCommand
}) {
  const memberPermissions = interaction.memberPermissions;
  if (targetCommand.options?.userPermissions && memberPermissions) {
    for (const permission of targetCommand.options.userPermissions) {
      const hasPermission = memberPermissions.has(permission);
      if (!hasPermission) {
        interaction.reply({
          content: `\u274C You do not have enough permission to run this command. Required permission: \`${permission}\``,
          ephemeral: true
        });
        return true;
      }
    }
  }
}

// src/handlers/command-handler/validations/index.ts
var validations_default = [botPermissions_default, devOnly_default, guildOnly_default, userPermissions_default];

// src/handlers/command-handler/utils/areSlashCommandsDifferent.ts
function areSlashCommandsDifferent(appCommand, localCommand) {
  if (!appCommand.options)
    appCommand.options = [];
  if (!localCommand.options)
    localCommand.options = [];
  if (!appCommand.description)
    appCommand.description = "";
  if (!localCommand.description)
    localCommand.description = "";
  if (localCommand.description !== appCommand.description || localCommand.options.length !== appCommand.options.length) {
    return true;
  }
}

// src/handlers/command-handler/functions/registerCommands.ts
import "colors";
async function registerCommands(commandHandler) {
  const client = commandHandler._data.client;
  const devGuildIds = commandHandler._data.devGuildIds;
  const commands = commandHandler._data.commands;
  client.once("ready", async () => {
    const devGuilds = [];
    for (const devGuildId of devGuildIds) {
      const guild = client.guilds.cache.get(devGuildId);
      if (!guild) {
        console.log(`\u23E9 Ignoring: Guild ${devGuildId} does not exist or client isn't in this guild.`.yellow);
        continue;
      }
      devGuilds.push(guild);
    }
    const appCommands = client.application?.commands;
    await appCommands?.fetch();
    const devGuildCommands = [];
    for (const guild of devGuilds) {
      const guildCommands = guild.commands;
      await guildCommands?.fetch();
      devGuildCommands.push(guildCommands);
    }
    for (const command of commands) {
      if (command.options?.deleted) {
        const targetCommand = appCommands?.cache.find((cmd) => cmd.name === command.data.name);
        if (!targetCommand) {
          console.log(`\u23E9 Ignoring: Command "${command.data.name}" is globally marked as deleted.`.yellow);
        } else {
          targetCommand.delete().then(() => {
            console.log(`\u{1F6AE} Deleted command "${command.data.name}" globally.`.green);
          });
        }
        for (const guildCommands of devGuildCommands) {
          const targetCommand2 = guildCommands.cache.find((cmd) => cmd.name === command.data.name);
          if (!targetCommand2) {
            console.log(
              `\u23E9 Ignoring: Command "${command.data.name}" is marked as deleted for ${guildCommands.guild.name}.`.yellow
            );
          } else {
            targetCommand2.delete().then(() => {
              console.log(
                `\u{1F6AE} Deleted command "${command.data.name}" in ${guildCommands.guild.name}.`.green
              );
            });
          }
        }
        continue;
      }
      let commandData = command.data;
      let editedCommand = false;
      const appGlobalCommand = appCommands?.cache.find((cmd) => cmd.name === command.data.name);
      if (appGlobalCommand) {
        const commandsAreDifferent = areSlashCommandsDifferent(appGlobalCommand, commandData);
        if (commandsAreDifferent) {
          appGlobalCommand.edit(commandData).then(() => {
            console.log(`\u2705 Edited command "${commandData.name}" globally.`.green);
          }).catch((error) => {
            console.log(`\u274C Failed to edit command "${commandData.name}" globally.`.red);
            console.error(error);
          });
          editedCommand = true;
        }
      }
      for (const guildCommands of devGuildCommands) {
        const appGuildCommand = guildCommands.cache.find((cmd) => cmd.name === commandData.name);
        if (appGuildCommand) {
          const commandsAreDifferent = areSlashCommandsDifferent(appGuildCommand, commandData);
          if (commandsAreDifferent) {
            appGuildCommand.edit(commandData).then(() => {
              console.log(
                `\u2705 Edited command "${commandData.name}" in ${guildCommands.guild.name}.`.green
              );
            }).catch((error) => {
              console.log(
                `\u274C Failed to edit command "${commandData.name}" in ${guildCommands.guild.name}.`.red
              );
              console.error(error);
            });
            editedCommand = true;
          }
        }
      }
      if (editedCommand)
        continue;
      if (command.options?.devOnly) {
        if (!devGuilds.length) {
          console.log(
            `\u23E9 Ignoring: Cannot register command "${command.data.name}" as no valid "devGuildIds" were provided.`.yellow
          );
          continue;
        }
        for (const guild of devGuilds) {
          const cmdExists = guild.commands.cache.some((cmd) => cmd.name === command.data.name);
          if (cmdExists)
            continue;
          guild?.commands.create(command.data).then(() => {
            console.log(`\u2705 Registered command "${command.data.name}" in ${guild.name}.`.green);
          }).catch((error) => {
            console.log(`\u274C Failed to register command "${command.data.name}" in ${guild.name}.`.red);
            console.error(error);
          });
        }
      } else {
        const cmdExists = appCommands?.cache.some((cmd) => cmd.name === command.data.name);
        if (cmdExists)
          continue;
        appCommands?.create(command.data).then(() => {
          console.log(`\u2705 Registered command "${command.data.name}" globally.`.green);
        }).catch((error) => {
          console.log(`\u274C Failed to register command "${command.data.name}" globally.`.red);
          console.error(error);
        });
      }
    }
  });
}

// src/handlers/command-handler/functions/handleCommands.ts
function handleCommands(commandHandler) {
  const client = commandHandler._data.client;
  client.on("interactionCreate", async (interaction) => {
    if (!interaction.isChatInputCommand() && !interaction.isContextMenuCommand())
      return;
    const targetCommand = commandHandler._data.commands.find((cmd) => cmd.data.name === interaction.commandName);
    if (!targetCommand)
      return;
    const { data, options, run, ...rest } = targetCommand;
    const commandObj = {
      data: targetCommand.data,
      options: targetCommand.options,
      ...rest
    };
    let canRun = true;
    for (const validationFunction of commandHandler._data.customValidations) {
      const stopValidationLoop = await validationFunction({
        interaction,
        client,
        commandObj
      });
      if (stopValidationLoop) {
        canRun = false;
        break;
      }
    }
    if (!canRun)
      return;
    if (!commandHandler._data.skipBuiltInValidations) {
      for (const validation of commandHandler._data.builtInValidations) {
        const stopValidationLoop = validation({
          targetCommand,
          interaction,
          handlerData: commandHandler._data
        });
        if (stopValidationLoop) {
          canRun = false;
          break;
        }
      }
    }
    if (!canRun)
      return;
    targetCommand.run({ interaction, client });
  });
}

// src/handlers/command-handler/CommandHandler.ts
import "colors";
var CommandHandler = class {
  _data;
  constructor({ ...options }) {
    this._data = {
      ...options,
      builtInValidations: [],
      commands: []
    };
  }
  async init() {
    await this.#buildCommands();
    this.#buildValidations();
    await this.#registerCommands();
    this.#handleCommands();
  }
  async #buildCommands() {
    const commandFilePaths = getFilePaths(this._data.commandsPath, true).filter(
      (path3) => path3.endsWith(".js") || path3.endsWith(".ts")
    );
    for (const commandFilePath of commandFilePaths) {
      const modulePath = toFileURL(commandFilePath);
      let commandObj = await import(modulePath);
      const compactFilePath = commandFilePath.split(process.cwd())[1] || commandFilePath;
      if (commandObj.default)
        commandObj = commandObj.default;
      if (!commandObj.data) {
        console.log(`\u23E9 Ignoring: Command ${compactFilePath} does not export "data".`.yellow);
        continue;
      }
      if (!commandObj.run) {
        console.log(`\u23E9 Ignoring: Command ${compactFilePath} does not export "run".`.yellow);
        continue;
      }
      this._data.commands.push(commandObj);
    }
  }
  #buildValidations() {
    for (const validationFunction of validations_default) {
      this._data.builtInValidations.push(validationFunction);
    }
  }
  async #registerCommands() {
    await registerCommands(this);
  }
  #handleCommands() {
    handleCommands(this);
  }
  get commands() {
    return this._data.commands;
  }
};

// src/handlers/event-handler/EventHandler.ts
import "colors";
var EventHandler = class {
  #data;
  constructor({ ...options }) {
    this.#data = {
      ...options,
      events: []
    };
  }
  async init() {
    await this.#buildEvents();
    this.#registerEvents();
  }
  async #buildEvents() {
    const eventFolderPaths = getFolderPaths(this.#data.eventsPath);
    for (const eventFolderPath of eventFolderPaths) {
      const eventName = eventFolderPath.replace(/\\/g, "/").split("/").pop();
      const eventFilePaths = getFilePaths(eventFolderPath, true).filter(
        (path3) => path3.endsWith(".js") || path3.endsWith(".ts")
      );
      const eventObj = {
        name: eventName,
        functions: []
      };
      this.#data.events.push(eventObj);
      for (const eventFilePath of eventFilePaths) {
        const modulePath = toFileURL(eventFilePath);
        let eventFunction = (await import(modulePath)).default;
        const compactFilePath = eventFilePath.split(process.cwd())[1] || eventFilePath;
        if (typeof eventFunction !== "function") {
          console.log(`\u23E9 Ignoring: Event ${compactFilePath} does not export a function.`.yellow);
          continue;
        }
        eventObj.functions.push(eventFunction);
      }
    }
  }
  #registerEvents() {
    const client = this.#data.client;
    for (const eventObj of this.#data.events) {
      client.on(eventObj.name, async (...params) => {
        for (const eventFunction of eventObj.functions) {
          const stopEventLoop = await eventFunction(...params, client);
          if (stopEventLoop) {
            break;
          }
        }
      });
    }
  }
  get events() {
    return this.#data.events;
  }
};

// src/handlers/validation-handler/ValidationHandler.ts
import "colors";
var ValidationHandler = class {
  #data;
  constructor({ ...options }) {
    this.#data = {
      ...options,
      validations: []
    };
  }
  async init() {
    await this.#buildValidations();
  }
  async #buildValidations() {
    const validationFilePaths = getFilePaths(this.#data.validationsPath, true).filter(
      (path3) => path3.endsWith(".js") || path3.endsWith(".ts")
    );
    for (const validationFilePath of validationFilePaths) {
      const modulePath = toFileURL(validationFilePath);
      let validationFunction = (await import(modulePath)).default;
      const compactFilePath = validationFilePath.split(process.cwd())[1] || validationFilePath;
      if (typeof validationFunction !== "function") {
        console.log(`\u23E9 Ignoring: Validation ${compactFilePath} does not export a function.`.yellow);
        continue;
      }
      this.#data.validations.push(validationFunction);
    }
  }
  get validations() {
    return this.#data.validations;
  }
};

// src/CommandKit.ts
import "colors";
var CommandKit = class {
  #data;
  constructor({ ...options }) {
    if (!options.client) {
      throw new Error('"client" is required when instantiating CommandKit.'.red);
    }
    if (options.validationsPath && !options.commandsPath) {
      throw new Error('"commandsPath" is required when "validationsPath" is set.'.red);
    }
    this.#data = {
      ...options,
      commands: []
    };
    this.#init();
  }
  async #init() {
    if (this.#data.eventsPath) {
      const eventHandler = new EventHandler({
        client: this.#data.client,
        eventsPath: this.#data.eventsPath
      });
      await eventHandler.init();
    }
    let validationFunctions = [];
    if (this.#data.validationsPath) {
      const validationHandler = new ValidationHandler({
        validationsPath: this.#data.validationsPath
      });
      await validationHandler.init();
      validationHandler.validations.forEach((v) => validationFunctions.push(v));
    }
    if (this.#data.commandsPath) {
      const commandHandler = new CommandHandler({
        client: this.#data.client,
        commandsPath: this.#data.commandsPath,
        devGuildIds: this.#data.devGuildIds || [],
        devUserIds: this.#data.devUserIds || [],
        devRoleIds: this.#data.devRoleIds || [],
        customValidations: validationFunctions,
        skipBuiltInValidations: this.#data.skipBuiltInValidations || false
      });
      await commandHandler.init();
      this.#data.commands = commandHandler.commands;
    }
  }
  get commands() {
    return this.#data.commands.map((cmd) => {
      const { run, ...command } = cmd;
      return command;
    });
  }
};
export {
  CommandKit
};
